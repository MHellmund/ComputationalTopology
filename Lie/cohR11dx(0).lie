#Author: Renjun Xu#
#E-mail: rxu@ucdavis.edu#
#This project is licensed under the terms of the MIT license.#

#Author: Renjun Xu#
#E-mail: rxu@ucdavis.edu#
#1. use Macaulay2 to compute Hilber series and enter in dimSeq()#
#2. use hhh(k) to compute the cohomology#
#3. make a conjecture of the cohomology formula based on hhh(k)#
#4. verify the conjecture of step 3 by dimension check with Hilbert series of step 1 using Mathematica, and enter in h_formula()#
#5. use hgenlist(int max_k) to compute the cohomology generators and verify them with the Macaulay2 numgens and generators#
#6. make a conjecture of the cohomology gens based on the degrees and the dimensions based on step 5#
##### line break required to define a new function #####
# NO even number of #
##### Setting the memory usage #####
# maxobjects 100000000
maxobjects 10000000
maxnodes 399999
monfil result_coh11redux.log
#on monitor	 ##cause Segmentation fault on server
# initialize the types of global variables #
# Nsusy=Number of supercharges #
# dimD= Dimension of the spacetime #
# dimD_sub, dimDsub=Dimension reduction of SO(D)->SO(d)*SO(10-d) #
# dimV=dim(v) #
# s=spinor, v=vector #
Nsusy=2
dimD=10
dimD_sub=10
dimV=dimD
dimx=dimD%8
rank=0;
lieG=T0;
#gsusy=T0;
s=X [];
v=X [];
iMax=0;
ARR=null(0,rank);
ARR_dim=null(0);
ARR_amb=null(0);
#ARR_resolv=null(0);
RR=null(0,1);
RR_resolv=null(0,1);
RR_amb=null(0,1);
ARR_seg=null(0,1);
RR_map=null(0,1);
#lenR=n_cols(RR)
lenR=0;
### Lie group of SO(D) ###
sod(int d)=
{
loc gn=4-2*(d%2);
loc rankd=d/2;
loc sogroup=T0;
if d==6 then sogroup=A3 else
 if d>4 then sogroup=Lie_group(gn,rankd) else
   if d==4 then sogroup=A1A1 else
       if d==3 then sogroup=A1 else
            if d==2 then sogroup=T1 else
                  sogroup=T0;
            fi;
      fi;
   fi;
 fi;
fi;
sogroup
}
### R symmetry -extended susy for Nsusy>=2 ###
rSusy(int dimDsub)=
{
loc Gsusy=T0;
loc dimDsubx=dimDsub%8;
if dimDsubx==0 || dimDsubx==4 then Gsusy=Lie_group(1,Nsusy-1)*T1 else
	if dimDsubx==1 || dimDsubx==2 || dimDsubx==3 then Gsusy=sod(Nsusy) else
		if dimDsubx==5 || dimDsubx==6 || dimDsubx==7 then Gsusy=Lie_group(3,Nsusy) else
			Gsusy=T0;
		fi;
	fi;
fi;
Gsusy
}
### the change of rank after extension of scalars to C, i.e. the complexification ###
Ncomplexify()=
{
loc Nt=Nsusy;
if dimx==1 || dimx==2 || dimx==3 then Nt=Nsusy/2;fi;
Nt
}
### the restriction matrix to do the branch decomposition, Nsusy=1, dimx!=5,6,7 *A1 ###
restrictionMatrix(int dimDsub)=
{
   loc m=id(rank);
   loc reorder=0;
   loc sod2=sod(dimD-dimDsub);
   # setdefault is a global def #
#   setdefault sod(dimD);
   if dimDsub%dimD==0 then m=id(rank)
   # T1 #
   else
         if dimDsub==2 || dimDsub==dimD-2 then m=res_mat(id(rank)-1,sod(dimD))
         else 
#              if dimDsub==4 || dimDsub==6 then reorder=1  else
              	#AB, BB, DA, A3A1A1,A1A1
                   if dimD%2==0 then
                   	if dimDsub%2==0 then
                   		#Not sure about the order of DD #
                   		if dimDsub<dimD/2 then reorder=1; fi;
                   	else
                   		if dimDsub>dimD/2 then reorder=1; fi;
                   	fi;
#                        if dimD-dimDsub==3  then reorder=1
#                        else
#                             if dimDsub>dimD/2 then reorder=1; fi;
#                        fi;
                  else
                       if dimDsub%2==1 && !(dimDsub>=5 && (dimD-dimDsub==4 || dimD-dimDsub==6)) then reorder=1
                       else
                       	if (dimDsub==4 || dimDsub==6) && dimD-dimDsub>=5 then reorder=1; fi;
                       fi;
                  fi;
#              fi;
              if reorder==0 then m=res_mat(sod(dimDsub)*sod2,sod(dimD))
              else 
                    m=res_mat(sod(dimD-dimDsub)*sod(dimDsub),sod(dimD));
             		for i=1 to Lie_rank(sod2) do
					m=*(*m-1+(*m)[1]);
                   od;
               fi;
         fi;
   fi;
   m
}
restrictionMatrix()=restrictionMatrix(dimD_sub)
### the vector representation of SO(d), 0<d<dimD ###
vDim(int d)=
{
loc rankd=d/2;
loc vd=X [];
if d==0 || d==1 then vd=X [] else
      if d==2 then vd=X [2]+ X [-2] else
         if d==3 then vd=X [2] else
            if d==4 then vd=X [1,1] else
               if d==6 then vd=X [0,1,0] else
                  if d>=5 then vd=X (1+null(rankd-1))
                  fi;
               fi;
            fi;
         fi;
      fi;
fi;
# different function type if use print(vd) #
vd
###
# d=0	T0	 v=[]
# d=1	T0	 v=[]
# d=2	T1	 v=[2]+[-2]
# d=3	SU(2)	 v=[2]
# d=4	A1A1	 v=[1,1]
# d=6	A3(NOT D3: labels reordered!)	 v=[0,1,0]
}
### the spinor representation of SO(D) ###
sDim(int d)=
{
loc rankd=d/2;
loc sd=X [];
if d==0 || d==1 then sd=X [] else
   if d==2 then sd=X [1]+ X [-1] else
      # d=6, D3=A3 #
      if d==6 then sd=X [0,0,1] +X [1,0,0] else
         if d>=4 && d%2==0 then sd=1X (null(rankd-1)+1)+ 1X (null(rankd-2)+1+0) else
            if d>=3 && d%2==1 then sd=1X (null(rankd-1)+1)
            fi;
         fi;
      fi;
   fi;
fi;
sd
###
# d=0	T0	 s=[]
# d=1	T0	 s=[]
# d=2	T1	 s=[1]+[-1]?
# d=3	SU(2)	 s=[1]
# d=4	A1A1	 s=[1,0]+[0,1]
# d=6	A3(NOT D3: labels reordered!)	 s=[1,0,0]+[0,0,1]
# d>=4 & even	D4	 s=[0,...,0,1]+[0,...,1,0]
# d>=3 & odd	B4	 s=[0,...,0,1]
# branch([0,0,0,0,1],A3A1A1,res_mat(A3A1A1,D5),D5) = 1X[0,0,1,1,0] +1X[1,0,0,0,1]
# branch([0,0,0,0,1],B3A1A1,res_mat(B3A1A1,B5),B5) =1X[0,0,1,0,1] +1X[0,0,1,1,0]
}
### the spinor representation of SO(d)XSO(D-d) ###
ssDim(int dimDsub)=
{
loc sd=X [];
loc ssusy1=X[];
loc ssusy2=X[];
loc dimDsub2=dimD-dimDsub;
  if dimDsub==0 || dimDsub==dimD then 
      if dimx==4 || dimx==0 then sd=sDim(dimD)
      else sd=X (expon(sDim(dimD),1))
      fi;
  else
  		###D=d1+d2=>dim(s_D)?=dim(s_d1)+dim(s_d2),dim(SO(d))=2^[(d-1)/2]###
  		###D(even)=d1(odd)+d2(odd);D(even)=2(d1(even)+d2(even));D(odd)=d1(odd)+2d2(even)###
  		if dimx==4 || dimx==0 then sd=sDim(dimDsub)^sDim(dimDsub2)
  		else
  		###when dimDsub,dimDsub2 both odd->one spinor
      	sd=X (expon(sDim(dimDsub),1)^expon(sDim(dimDsub2),1))+ ((dimDsub*dimDsub2+1)%2) X (expon(sDim(dimDsub),2-dimDsub%2)^expon(sDim(dimDsub2),2-dimDsub2%2))
      fi;
	fi;
	###supersymmery###
#	if Nsusy==2 then sd=sd^(X[1])
#	else if Nsusy>2 then
#  	ssusy=null(Nsusy-2);
#  	sd=X (expon(sd,1)^(1+ssusy))+X(expon(sd,length(sd))^(ssusy+1));
#		fi;
#	fi;
	###complexification & supersymmery###
	if dimx==1 || dimx==2 || dimx==3 then sd=sd^vDim(Nsusy) else
		###Nsusy should be doubled below###
		if dimx==5 || dimx==6 || dimx==7 then sd=sd^(X(1+null(Nsusy-1))) else	
			#if dimx==4 || dimx==0#
			if Nsusy==2 then ssusy1=X[1];ssusy2=X[1];else
				if Nsusy>2 then ssusy1=X(1+null(Nsusy-2));ssusy2=X(null(Nsusy-2)+1);
			fi;fi;
			if length(sd)==4 then
					###test 8=6+2,8=4+4###
					sd=(sd[2]+sd[3])^ssusy1^(X[1])+(sd[1]+sd[4])^ssusy2^(X[-1])
				else
					sd=sd[1]^ssusy1^(X[1])+sd[length(sd)]^ssusy2^(X[-1])
			fi;
		fi;
	fi;
   ### note any torus or even SO(d) will be moved to the end =>gsusy,lieG ###
   ### the spinor not changes only for SO(2)*SO(D-2) <->SO(D-2)*SO(2) ###
     if dimDsub==2 then
      	sd=X (*(*support(sd)-1+(*support(sd))[1]));
     else
				if dimDsub2==2 then 
				sd=X (*(*support(sd)-dimD/2+(*support(sd))[dimD/2]));
      	fi;
  	 fi;
  sd
}
##### Set up the parameters: s, v, rank, the default group #####
setparam(int dimDsub)=
{
dimD_sub=dimDsub;
dimV=dimD;
dimx=dimD%8;
rank=dimD/2;
rank2=(dimD-dimDsub)/2;
#Ncomplexify=0;
s=X [];
v=X [];
#vsusy=null(Nsusy-1);
#gsusy=T0;
lieG=T0;
# loc s0=poly_null(rank+Ncomplexify); 
# loc v0=poly_null(rank+Ncomplexify);
### note any torus or even SO(d) will be moved to the end #
    lieG=sod(dimDsub)*sod(dimD-dimDsub);
if Nsusy==1 then
  if dimx==5 || dimx==6 || dimx==7 then  lieG=lieG*A1 else
  	if dimx==0 || dimx==4 then lieG=lieG*T1;fi;
  fi;
 else
  lieG=lieG*rSusy(dimD);
fi;
#setdefault sod(dimD);
s=ssDim(dimDsub);
### if Nsusy=1 ###
# the torus T1 always reordered to the end, check the labeling by diagram #
   if dimDsub==2 then 
      v=X (null(rank2+Ncomplexify)^[2])+X (null(rank2+Ncomplexify)^[-2]); 
   else
      v=X (expon(vDim(dimDsub),1)^null(rank2+Ncomplexify));
   fi;
#   if Nsusy>1 then
#         for i=1 to length(s) do
#          s= X ((null(rank-1)+1)^(1+ssusy)) + X ((null(rank-1)+1)^(ssusy+1));
#             s0=s0+coef(s,i) X ((expon(s,i))^(1+ssusy)) + coef(s,i) X ((expon(s,i))^(ssusy+1));
#         od;
#         for i=1 to length(v) do
#             v= X ((1+null(rank-1))^vsusy);
#              v0=v0+coef(v,i) X ((expon(v,i))^vsusy);
#          od;
#         s=s0; v=v0;
#   fi;
#if dimx==1 || dimx==2 || dimx==3 then
#   Ncomplexify=0; 
#   if Nsusy==1 then #
#         s= X (null(rank-1)+1);
#         v= X (1+null(rank-1));
#         if dimDsub==2 then
#             s=branch(s,lieG,res_mat(closure(id(rank)-1)));
#             v=branch(v,lieG,res_mat(closure(id(rank)-1)));
#          else if dimDsub>0 then
#             s=branch(s,lieG,res_mat(lieG));
#             v=branch(v,lieG,res_mat(lieG));
#          fi; fi;
#     if dimD==3 then v= X ([2]^vsusy); fi;
# Note that LiE rearrange the torus to the end of other simple groups #
### the following code has not been updated for dim reduction! ###
# else if dimx==4 || dimx==0 then
#   Ncomplexify=0; 
#      v=1X ((1+null(rank-1))^vsusy);
#   if Nsusy==1 then
#      s=X(null(rank-1)+1)+X (null(rank-2)+1+0);
 #  else
 #     s=1X ((null(rank-1)+1)^(1+ssusy))+ 1X ((null(rank-2)+1+0)^(ssusy+1));
 #  fi;
   #      if dimD==4 then
   #         v=X([1,1]^vsusy);
   #       fi;
#else
# if dimx==5 || dimx==6 || dimx==7 then
#   Ncomplexify=1; 
#   if Nsusy==1 then
#        s= X (null(rank-1)+1+1);
#        v= X(1+null(rank));
 #   else
#        s= X ((null(rank-1)+1+1)^(1+ssusy))+X ((null(rank-1)+1+1)^(ssusy+1));
#        v= X((1+null(rank))^vsusy);
#     fi;
#   lieG=lieG*A1;
#fi;
#fi;
#setdefault lieG*gsusy;
setdefault lieG;
#rank=rank+Ncomplexify+Nsusy-1;
rank=Lie_rank;
#DEBUG:
#print(lieG);print(v);
dimV=dim(v);
}
setparam(dimD_sub)
### the dimension of cohomologies calculated by Macaulay2 ###
dimSeq(int d, dimDsub, k, n)=
{
loc dimsi=0;
if Nsusy==1 then
### D=4 ==> ###
if d==4 && k>=0 then
	if dimDsub==4 then
		if n==0 then
			if k==0 then dimsi=1 else dimsi=2*(1 + k)
			fi; else
			if n==1 && k>=3 then
				if k==4 then dimsi=9 else dimsi=4*(-2+k) 
				fi; else
				if n==2 && k>=6 then dimsi=2*(-5+k)
							else dimsi=0
				fi;
			fi;
		fi;
	fi;
### D=5 ==> ###
else if d==5 && k>=0 then
	if dimDsub==5 then
		if n==0 then
			if k==2 then dimsi=31 else dimsi=(1 + k)^2*(2 + k)*(3 + k)/6 
			fi; else
			if n==1 && k>=4 then dimsi=(-3 + k)*(-1 + k)^2*(1 + k)/3 else
				if n==2 && k>=6 then dimsi=(-5 + k)*(-4 + k)*(-3 + k)^2/6
							else dimsi=0
				fi;
			fi;
		fi;
	fi;
### D=6 ==> ###
else if d==6 && k>=0 then
	if dimDsub==6 then
		if n==0 then dimsi=(1 + k)^2*(2 + k)*(3 + k)/6 else
			if n==1 && k>=3 then 
				if k==4 then dimsi=46 else dimsi=(-2 + k)*(-1 + k)^2*(1 + k)/2
				fi; else
				if n==2 && k>=6 then dimsi=(-5 + k)*(-3 + k)^2*(-2 + k)/2 else
					if n==3 && k>=8 then dimsi=(-7 + k)*(-6 + k)*(-5 + k)^2/6
							else dimsi=0
					fi;
				fi;
			fi;
		fi;
	fi;
### D=10 ==> ###
else if d==10 && k>=0 then
	if dimDsub==10 then
		if n==0 then dimsi=((1 + k)*(2 + k)*(3 + k)^2 *(4 + k)^2 *(5 + k)^2 *(6 + k)*(7 + k))/302400 else
			if n==1 && k>=3 then 
				if k==4 then dimsi=211 else
							dimsi=((-2 + k)*(-1 + k) *k* (1 + k)^2 *(2 + k)*(3 + k)^2 *(4 + k)*(5 + k))/60480
				fi; else
				if n==2 && k>=6 then dimsi=((-5 + k)*(-3 + k)*(-2 + k)^2 *(-1 + k)^2 *k* (1 + k)*(2 + k)*(3 + k))/30240 else
					if n==3 && k>=8 then dimsi=((-7 + k)*(-6 + k)*(-5 + k)*(-4 + k)*(-3 + k)^2 *(-2 + k)^2 *(-1 + k)*(1 + k))/30240 else
						if n==4 && k>=10 then dimsi=((-9 + k)*(-8 + k)*(-7 + k)^2 *(-6 + k)*(-5 + k)^2 *(-4 + k)*(-3 + k)*(-2 + k))/60480 else
							if n==5 && k>=12 then dimsi=((-11 + k)*(-10 + k)*(-9 + k)^2 *(-8 + k)^2 *(-7 + k)^2 *(-6 + k)*(-5 + k))/302400 
							else dimsi=0
							fi;
						fi;
					fi;
				fi;
			fi;
		fi;
	else if dimDsub==9 then
		if n==0 then 
			if k==2 then dimsi=127 else
				dimsi=((1 + k)*(2 + k)*(3 + k)^2 *(4 + k)^2 *(5 + k)^2 *(6 + k)*(7 + k))/302400
			fi; else
			if n==1 && k>=4 then dimsi=((-3 + k)*(-1 + k) *k* (1 + k)^2 *(2 + k)*(3 + k)^2 *(4 + k)*(5 + k))/75600 else
				if n==2 && k>=6 then dimsi=((-5 + k)*(-4 + k)*(-3 + k)*(-2 + k)*(-1 + k)^2 *k* (1 + k)*(2 + k)*(3 + k))/50400 else
					if n==3 && k>=8 then dimsi=((-7 + k)*(-6 + k)*(-5 + k)^2 *(-4 + k)*(-3 + k)^2 *(-2 + k)*(-1 + k)*(1 + k))/75600 else
						if n==4 && k>=10 then dimsi=((-9 + k)*(-8 + k)*(-7 + k)^2 *(-6 + k)^2 *(-5 + k)^2 *(-4 + k)*(-3 + k))/302400
							else dimsi=0
						fi;
					fi;
				fi;
			fi;
		fi;
	else if dimDsub==8 then
		if n==0 then dimsi=((1 + k)*(2 + k)*(3 + k)*(4 + k)*(5 + k)*(2520 + 2634*k + 1295*k^2 + 245*k^3 + 25*k^4 + k^5))/302400 else
			if n==1 && k>=4 then dimsi=((-3 + k)*(-2 + k)*(-1 + k) *k* (1 + k)^2 *(2 + k)*(3 + k)*(140 + 37*k + 3*k^2))/302400 else
				if n==2 && k>=6 then dimsi=((-5 + k)*(-4 + k)*(-3 + k)^2 *(-2 + k)*(-1 + k)^2 *k* (1 + k)*(14 + 3*k))/302400 else
					if n==3 && k>=8 then dimsi=((-7 + k)*(-6 + k)*(-5 + k)^2 *(-4 + k)^2 *(-3 + k)^2 *(-2 + k)*(-1 + k))/302400
							else dimsi=0
					fi;
				fi;
			fi;
		fi;
	else if dimDsub==7 then
		if n==0 then dimsi=((1 + k)*(2 + k)*(3 + k)*(4 + k)*(5 + k)*(2520 + 2694*k + 1175*k^2 + 305*k^3 + 25*k^4 + k^5))/302400 else
			if n==1 && k>=4 then dimsi=((-3 + k)*(-2 + k)*(-1 + k)^2 *k* (1 + k)^2 *(2 + k)*(3 + k)*(10 + k))/151200 else
				if n==2 && k>=6 then dimsi=((-5 + k)*(-4 + k)*(-3 + k)^2 *(-2 + k)^2 *(-1 + k)^2 *k* (1 + k))/302400
							else dimsi=0
				fi;
			fi;
		fi;
	else if dimDsub==6 then
		if n==0 then dimsi=((1 + k)*(2 + k)*(3 + k)*(4 + k)*(5 + k)*(7560 + 8022*k + 3605*k^2 + 855*k^3 + 115*k^4 + 3*k^5))/907200 else
			if n==1 && k>=4 then dimsi=((-3 + k)*(-2 + k)*(-1 + k)^2 *k^2 *(1 + k)^2 *(2 + k)*(3 + k))/302400
							else dimsi=0
			fi;
		fi;
	else if dimDsub==5 then
		if n==0 then dimsi=((1 + k)*(2 + k)*(3 + k)^2 *(4 + k)*(5 + k)*(315 + 228*k + 74*k^2 + 12*k^3 + k^4))/113400
					else dimsi=0
		fi;
	else if dimDsub==4 then
		if n==0 then dimsi=((1 + k)*(2 + k)*(3 + k)*(4 + k)*(5 + k)*(6 + k)*(7 + k)*(495 + 368*k + 110*k^2 + 16*k^3 + k^4))/2494800
					else dimsi=0
		fi;
	else if dimDsub==3 then
		if n==0 then dimsi=((1 + k)*(2 + k)*(3 + k)*(4 + k)*(5 + k)^2 *(6 + k)*(7 + k)*(8 + k)*(9 + k)*(33 + 10*k + k^2))/59875200
					else dimsi=0
		fi;
	else if dimDsub==2 then
		if n==0 then dimsi=((1 + k)*(2 + k)*(3 + k)*(4 + k)*(5 + k)*(6 + k)*(7 + k)*(8 + k)*(9 + k)*(10 + k)*(11 + k)*(39 + 12*k + k^2))/1556755200
					else dimsi=0
		fi;
	else if dimDsub==1 then
		if n==0 then dimsi=(1 + k)*(2 + k)*(3 + k)*(4 + k)*(5 + k)*(6 + k)*(7 + k)^2 *(8 + k)*(9 + k)*(10 + k)*(11 + k)*(12 + k)*(13 + k)/43589145600
					else dimsi=0
		fi;
	fi;fi;fi;fi;fi;fi;fi;fi;fi;fi;
### <== D=10 			###
###     D=11 ==> ###
else if d==11 && k>=0 then
	if dimDsub==11 then
		if n==0 then dimsi=((1 + k)*(2 + k)*(3 + k)*(4 + k)*(5 + k)*(6 + k)*(7 + k)^2 *(8 + k)^2 *(9 + k)^2 *(10 + k)*(11 + k)*(12 + k)*(13 + k)*(14 + k)*(15 + k)*(38760 + 13232*k + 2107*k^2 + 160*k^3 + 5*k^4))/25545471085854720000 else
			if n==1 && k>=4 then dimsi=(-3 + k)*(-2 + k)*(-1 + k) *k* (1 + k)*(2 + k)*(3 + k)^2 *(4 + k)*(5 + k)^2 *(6 + k)*(7 + k)^2 *(8 + k)*(9 + k)*(10 + k)*(11 + k)*(12 + k)*(13 + k)*(58 + 10*k + k^2)/2554547108585472000 else
				if n==2 && k>=6 then dimsi=((-5 + k)*(-4 + k)*(-3 + k)*(-2 + k)*(-1 + k) *k* (1 + k)^2 *(2 + k)^2 *(3 + k)^2 *(4 + k)*(5 + k)*(6 + k)*(7 + k)*(8 + k)*(9 + k)*(7140 + 908*k + 307*k^2 + 40*k^3 + 5*k^4))/25545471085854720000
							else dimsi=0
				fi;
			fi;
		fi;
	else if dimDsub==10 then
		if n==0 then dimsi=(1 + k)*(2 + k)*(3 + k)*(4 + k)*(5 + k)*(6 + k)*(7 + k)*(8 + k)*(9 + k)*(10 + k)*(11 + k)*(12 + k)*(13 + k)*(4102358400 + 3517874640*k + 1377034344*k^2 + 323465858*k^3 + 50304233*k^4 + 5370505*k^5 + 392126*k^6 + 18592*k^7 + 497*k^8 + 5*k^9)/25545471085854720000 else
			if n==1 && k>=4 then dimsi=(-3 + k)*(-2 + k)*(-1 + k)*k*(1 + k)*(2 + k)*(3 + k)^2 *(4 + k)^2 *(5 + k)^2 *(6 + k)*(7 + k)*(8 + k)*(9 + k)*(10 + k)*(11 + k)*(10584 + 2776*k + 667*k^2 + 80*k^3 + 5*k^4)/25545471085854720000
							else dimsi=0
			fi;
		fi;
	else if dimDsub==9 then
		if n==0 then dimsi=(1 + k)*(2 + k)*(3 + k)*(4 + k)*(5 + k)*(6 + k)*(7 + k)^2 *(8 + k)*(9 + k)*(10 + k)*(11 + k)*(12 + k)*(13 + k)*(50363775 + 35942760*k + 11778948*k^2 + 2314760*k^3 + 299446*k^4 + 26264*k^5 + 1540*k^6 + 56*k^7 + k^8)/2195313921440640000
					else dimsi=0
		fi;
	else if dimDsub==8 then
		if n==0 then dimsi=(1 + k)*(2 + k)*(3 + k)*(4 + k)*(5 + k)*(6 + k)*(7 + k)*(8 + k)*(9 + k)*(10 + k)*(11 + k)*(12 + k)*(13 + k)*(14 + k)*(15 + k)*(77224455 + 55401408*k + 17929148*k^2 + 3430336*k^3 + 426174*k^4 + 35392*k^5 + 1932*k^6 + 64*k^7 + k^8)/100984440386269440000
					else dimsi=0
		fi;
	else if dimDsub==7 then
		if n==0 then dimsi=(1 + k)*(2 + k)*(3 + k)*(4 + k)*(5 + k)*(6 + k)*(7 + k)*(8 + k)*(9 + k)^2 *(10 + k)*(11 + k)*(12 + k)*(13 + k)*(14 + k)*(15 + k)*(16 + k)*(17 + k)*(1514205 + 732798*k + 155731*k^2 + 18612*k^3 + 1327*k^4 + 54*k^5 + k^6)/4847253138540933120000
					else dimsi=0
		fi;
	else if dimDsub==6 then
		if n==0 then dimsi=(1 + k)*(2 + k)*(3 + k)*(4 + k)*(5 + k)*(6 + k)*(7 + k)*(8 + k)*(9 + k)*(10 + k)*(11 + k)*(12 + k)*(13 + k)*(14 + k)*(15 + k)*(16 + k)*(17 + k)*(18 + k)*(19 + k)*(1992375 + 967980*k + 202399*k^2 + 23400*k^3 + 1585*k^4 + 60*k^5 + k^6)/242362656927046656000000
					else dimsi=0
		fi;
	else if dimDsub==5 then
		if n==0 then dimsi=(1 + k)*(2 + k)*(3 + k)*(4 + k)*(5 + k)*(6 + k)*(7 + k)*(8 + k)*(9 + k)*(10 + k)*(11 + k)^2 *(12 + k)*(13 + k)*(14 + k)*(15 + k)*(16 + k)*(17 + k)*(18 + k)*(19 + k)*(20 + k)*(21 + k)*(22425 + 6644*k + 786*k^2 + 44*k^3 + k^4)/12602858160206426112000000
					else dimsi=0
		fi;
	else if dimDsub==4 then
		if n==0 then dimsi=(1 + k)*(2 + k)*(3 + k)*(4 + k)*(5 + k)*(6 + k)*(7 + k)*(8 + k)*(9 + k)*(10 + k)*(11 + k)*(12 + k)*(13 + k)*(14 + k)*(15 + k)*(16 + k)*(17 + k)*(18 + k)*(19 + k)*(20 + k)*(21 + k)*(22 + k)*(23 + k)*(26325 + 7824*k + 902*k^2 + 48*k^3 + k^4)/680554340651147010048000000
					else dimsi=0
		fi;
	else if dimDsub==3 then
		if n==0 then dimsi=(1 + k)*(2 + k)*(3 + k)*(4 + k)*(5 + k)*(6 + k)*(7 + k)*(8 + k)*(9 + k)*(10 + k)*(11 + k)*(12 + k)*(13 + k)^2 *(14 + k)*(15 + k)*(16 + k)*(17 + k)*(18 + k)*(19 + k)*(20 + k)*(21 + k)*(22 + k)*(23 + k)*(24 + k)*(25 + k)*(189 + 26*k + k^2)/38111043076464232562688000000
					else dimsi=0
		fi;
	else if dimDsub==2 then
		if n==0 then dimsi=(1 + k)*(2 + k)*(3 + k)*(4 + k)*(5 + k)*(6 + k)*(7 + k)*(8 + k)*(9 + k)*(10 + k)*(11 + k)*(12 + k)*(13 + k)*(14 + k)*(15 + k)*(16 + k)*(17 + k)*(18 + k)*(19 + k)*(20 + k)*(21 + k)*(22 + k)*(23 + k)*(24 + k)*(25 + k)*(26 + k)*(27 + k)*(203 + 28*k + k^2)/2210440498434925488635904000000
					else dimsi=0
		fi;
	else if dimDsub==1 then
		if n==0 then dimsi=(1 + k)*(2 + k)*(3 + k)*(4 + k)*(5 + k)*(6 + k)*(7 + k)*(8 + k)*(9 + k)*(10 + k)*(11 + k)*(12 + k)*(13 + k)*(14 + k)*(15 + k)^2 *(16 + k)*(17 + k)*(18 + k)*(19 + k)*(20 + k)*(21 + k)*(22 + k)*(23 + k)*(24 + k)*(25 + k)*(26 + k)*(27 + k)*(28 + k)*(29 + k)/132626429906095529318154240000000
					else dimsi=0
		fi;
	fi;fi;fi;fi;fi;fi;fi;fi;fi;fi;fi;
fi;fi;fi;fi;fi;
else if Nsusy==2 then
### D=4 ==> ###
	if d==4 && k>=0 then
		if dimDsub==4 then
			if n==0 then dimsi=(1 + k)*(6 + 9*k + 8*k^2 + k^3)/6 else
				if n==1 && k>=4 then dimsi=(-3 + k)*(-2 + k)*(-1 + k)^2/6
								else dimsi=0
				fi;
			fi;
		fi;
#	else if d==10 && k>=0 then
#		if dimDsun==10 then
#	
fi;#d=4
else if Nsusy==3 then
### D=4 ==> ###
if d==4 && k>=0 then
	if dimDsub==4 then
		if n==0 then dimsi=(1 + k)*(2 + k)*(3 + k)*(105 + 128*k + 64*k^2 + 16*k^3 + 2*k^4)/630
				else dimsi=0
		fi;
	fi;
fi;#d=4
fi;fi;fi;#Nsusy=3
dimsi
}
### The cohomologies calculated by hhh(k) ###
h_formula(int d, dimDsub, k, n)=
{
loc h0=poly_null(rank);
if Nsusy==1 then
#D=3+0:A1
#H{3,1}=[1]
#H{4,1}=[0]
if d==2 && k>=0 then
	if dimDsub==2 then 
		if n==0 then
			if k==0 then h0=X[0]
			else if k==1 then h0=X[-1]
			fi;fi;
		else if n==1 then
			if k==2 then h0=X[2]
			else if k==3 then h0=X[1]
			fi;fi;
		fi;fi;
	fi;		
else if d==3 && k>=0 then
	if dimDsub==3 then 
		if n==0 then
			if k==0 then h0=X[0]
			else if k==1 then h0=X[1]
			fi;fi;
		else if n==1 then
			if k==3 then h0=X[1]
			else if k==4 then h0=X[0]
			fi;fi;
		fi;fi;
	fi;		
#D=4+0:A1A1
#H^{k,0}=[0,k]+[k,0]
#H^{k,1}=[1,k-3]+[k-3,1]
#	H^{4,1}=[0,0]+ 2X[1,1]
#H^{k,2}= [0,k-6]+[k-6,0]
else if d==4 && k>=0 then
	if dimDsub==4 then 
		if n==0 then
						if k==0 then h0=X[0,0] else h0=X[0,k]+X[k,0]
						fi;
		else if n==1 && k>=3 then
						if k==4 then h0=X[0,0]+ 2X[1,1] else h0=X[1,k-3]+X[k-3,1]
						fi;
		else if n==2 && k>=6 then h0=X[0,k-6]+X[k-6,0]
		else h0=poly_null(rank)
		fi;fi;fi;
	fi;
#D=5+0:B2
#H^k,0=[0,k,k]	k!=2
#H^2,0=1X[0,0,0] +1X[0,2,2]
#H^k,1=[1,k-4,k-2]
#H^k,2=[0,k-6,k-4]
else if d==5 && k>=0 then
	if dimDsub==5 then 
		if n==0 then
			if k==2 then h0=X[0,0,0] +X[0,2,2] else h0=X[0,k,k]
			fi;
		else if n==1 && k>=4 then h0=h0+X[1,k-4,k-2]
		else if n==2 && k>=6 then h0=h0+X[0,k-6,k-4]
		else h0=poly_null(rank)
		fi;fi;fi;
	fi;
#D=6+0:D3
#H^{k,0}=[0,0,k,k]
#H^{k,1}=[1,0,k-3,k-2]
#	H^{4,1}=[0,0,0,0]+[1,0,1,2]
#H^{k,2}=[0,1,k-6,k-4]
#H^{k,3}=[0,0,k-8,k-6]
else if d==6 && k>=0 then
	if dimDsub==6 then 
		if n==0 then h0=X[0,0,k,k]
		else if n==1 && k>=3 then
			if k==4 then h0=X[0,0,0,0] + X[1,0,1,2]
			else h0=X[1,0,k-3,k-2]
			fi;
		else if n==2 && k>=6 then h0=X[0,1,k-6,k-4]
		else if n==3 && k>=8 then h0=X[0,0,k-8,k-6]
		else h0=poly_null(rank)
		fi;fi;fi;fi;
	fi;	
#D=10+0:D5
#H^k,0=	X[0,0,0,0,k]
#H^k,1=	X[0,0,0,1,k-3]	k>=3
#	X[0,0,0,0,0] + X[0,0,0,1,1]	k=4
#H^k,2=	X[0,0,1,0,k-6]	k>=6
#H^k,3=	X[0,1,0,0,k-8]	k>=8
#H^k,4=	X[1,0,0,0,k-10]	k>=10
#H^k,5=	X[0,0,0,0,k-12]	k>=12
#D=9+1:B4
#H^k,0=	X[0,0,0,k]	k!=2
#	1X[0,0,0,0] +1X[0,0,0,2]	k=2
#H^k,1=	X[0,0,1,k-4]	k>=4
#H^k,2=	X[0,1,0,k-6]	k>=6
#H^k,3=	X[1,0,0,k-8]	k>=8
#H^k,4=	X[0,0,0,k-10]	k>=10
#D=8+2:D4T1
#H^k,0=X[0,0,k-i,i,k-2i],{i,1,k-1}
#+X[0,0,k-2i,0,k]+X[0,0,0,k-2i,-k],{i,0,[k/2]}
#H^k,1=X[0,1,k-4-i,i,k-4-2i],{i,0,k-4}		k>=4
#H^k,2=X[1,0,k-6-i,i,k-6-2i],{i,0,k-6}		k>=6
#H^k,3=X[0,0,k-8-i,i,k-8-2i],{i,0,k-8}		k>=8
#D=7+3:B3A1
#H^k,0=X[0,i,k-2i,k-2i],{i,1,[k/2]}
#	+X[0,0,k-2i,k],{i,0,[k/2]}
#H^k,1=X[1,i,k-4-2i,k-4-2i],{i,0,[(k-4)/2]}		k>=4
#H^k,2=X[0,i,k-6-2i,k-6-2i],{i,0,[(k-6)/2]}		k>=6
#D=6+4:A3A1A1
#H^k,0=X[j,i,k-j-2i,j,k-j-2i],{i,0,[k/2]},{j,0,k-2i}
#	+X[j,0,k-2i+j,i,k-i],{i,1,k-1},{j,Max[0,2i-k],i-1}	
#	=X[j,0,k-2i+j,i,k-i],{i,1,[k/2]},{j,0,i-1}
#	+X[j,0,k-2i+j,i,k-i],{i,[k/2]+1,k-1},{j,2i-k,i-1}
#H^k,1=X[j,i,k-4-j-2i,j,k-4-j-2i],{i,0,[(k-4)/2]},{j,0,k-4-2i}		k>=4
#D=5+5:B2B2
#H^k,0=X[j,k-2i,i,k-2i],{i,1,[k/2]},{j,0,i-1}
#	+X[i,k-2i-2j,i,k-2i-2j],{i,0,[k/2]},{j,0,[(k-2i)/2]}
#D=4+6:A1A1A3
#H^k,0=(i+1)X[j,k-2i-j,j,i,k-2i-j],{i,0,[k/2]},{j,0,k-2i}
#D=3+7:A1B3
#H^k,0=X[k-2i,j,i-j,k-2i],{i,0,[k/2]},{j,0,i}
#D=2+8:D4T1
#H^k,0=X[i,0,k-2i-j,j,k-2i-2j],{i,0,[k/2]},{j,0,k-2i}
#D=1+9:B4
#H^k,0=X[i,0,0,k-2i],{i,0,[k/2]}
else if d==10 && k>=0 then
	if dimDsub==10 then 
		if n==0 then h0=X[0,0,0,0,k]
		else if n==1 && k>=3 then
			if k==4 then h0=X[0,0,0,0,0] + X[0,0,0,1,1]
			else h0=X[0,0,0,1,k-3]
			fi;
		else if n==2 && k>=6 then h0=X[0,0,1,0,k-6]
		else if n==3 && k>=8 then h0=X[0,1,0,0,k-8]
		else if n==4 && k>=10 then h0=X[1,0,0,0,k-10]
		else if n==5 && k>=12 then h0=X[0,0,0,0,k-12]
		else h0=poly_null(rank)
		fi;fi;fi;fi;fi;fi;
	else if dimDsub==9 then
		if n==0 then
			if k==2 then h0=X[0,0,0,0] +X[0,0,0,2]
			else h0=X[0,0,0,k]
			fi;
		else if n==1 && k>=4 then h0=X[0,0,1,k-4]
		else if n==2 && k>=6 then h0=X[0,1,0,k-6]
		else if n==3 && k>=8 then h0=X[1,0,0,k-8]
		else if n==4 && k>=10 then h0=X[0,0,0,k-10]
		else h0=poly_null(rank)
		fi;fi;fi;fi;fi;
	else if dimDsub==8 then
		if n==0 then 
			if k==0 then h0=X[0,0,0,0,0]
			 else
				for i=1 to k-1 do	h0=h0+X[0,0,k-i,i,k-2*i]; od;
				for i=0 to k/2 do	h0=h0+X[0,0,k-2*i,0,k]+X[0,0,0,k-2*i,-k]; od;
			fi;
		else if n==1 && k>=4 then
			 for i=0 to k-4 do h0=h0+X[0,1,k-4-i,i,k-4-2*i];od;
		else if n==2 && k>=6 then
			 for i=0 to k-6 do h0=h0+X[1,0,k-6-i,i,k-6-2*i];od;
		else if n==3 && k>=8 then
			 for i=0 to k-8 do h0=h0+X[0,0,k-8-i,i,k-8-2*i];od;
		else h0=poly_null(rank)
		fi;fi;fi;fi;
	else if dimDsub==7 then
		if n==0 then h0=X[0,0,k,k];
			for i=1 to k/2 do	h0=h0+X[0,i,k-2*i,k-2*i]+X[0,0,k-2*i,k]; od;
		else if n==1 && k>=4 then
			 for i=0 to (k-4)/2 do h0=h0+X[1,i,k-4-2*i,k-4-2*i];od;
		else if n==2 && k>=6 then
			 for i=0 to (k-6)/2 do h0=h0+X[0,i,k-6-2*i,k-6-2*i];od;
		else h0=poly_null(rank)
		fi;fi;fi;
	else if dimDsub==6 then
		if n==0 then
			for i=0 to k/2 do
				for j=0 to k-2*i do	h0=h0+X[j,i,k-j-2*i,j,k-j-2*i]
			od;od;
			for i=1 to k/2 do
				for j=0 to i-1 do	h0=h0+X[j,0,k-2*i+j,i,k-i]
			od;od;
			for i=k/2+1 to k-1 do 
				for j=2*i-k to i-1 do h0=h0+X[j,0,k-2*i+j,i,k-i]
			od;od;
		else if n==1 && k>=4 then
			 for i=0 to (k-4)/2 do
			 	for j=0 to k-4-2*i do h0=h0+X[j,i,k-4-j-2*i,j,k-4-j-2*i]
			od;od;
		else h0=poly_null(rank)
		fi;fi;
	else if dimDsub==5 then
		if n==0 then
			for i=1 to k/2 do
				for j=0 to i-1 do	h0=h0+X[j,k-2*i,i,k-2*i]
			od;od;
			for i=0 to k/2 do
				for j=0 to (k-2*i)/2 do h0=h0+X[i,k-2*i-2*j,i,k-2*i-2*j]
			od;od;
		else h0=poly_null(rank)
		fi;
	else if dimDsub==4 then
		if n==0 then
			for i=0 to k/2 do
				for j=0 to k-2*i do	h0=h0+(i+1) X [j,k-2*i-j,j,i,k-2*i-j]
			od;od;
		else h0=poly_null(rank)
		fi;
	else if dimDsub==3 then
		if n==0 then
			for i=0 to k/2 do
				for j=0 to i do	h0=h0+X[k-2*i,j,i-j,k-2*i]
			od;od;
		else h0=poly_null(rank)
		fi;
	else if dimDsub==2 then
		if n==0 then
			for i=0 to k/2 do
				for j=0 to k-2*i do h0=h0+X[i,0,k-2*i-j,j,k-2*i-2*j]
			od;od;
		else h0=poly_null(rank)
		fi;
	else if dimDsub==1 then
		if n==0 then for i=0 to k/2 do h0=h0+X[i,0,0,k-2*i]
			od;
		else h0=poly_null(rank)
		fi;
	fi;fi;fi;fi;fi;fi;fi;fi;fi;fi;
#D=11+0:B5
#H^k,0=Sum[0,i,0,0,k-2i],{i,0,k/2}
#H^k,1=Sum[1,i,0,0,k-4-2i],{i,0,(k-4)/2}
#H^k,2=Sum[0,i,0,0,k-6-2i],{i,0,(k-6)/2}
#D=10+1:D5T0
#H^k,0=X[0,i,0,j,k-2i-j-2l],{i,0,k/2},{j,0,k-2i},{l,0,(k-2i-j)/2,l!=2}
#	X[i,j,0,l,k-2i-2j-l],{i,1,k/2},{j,0,(k-2i)/2},{l,0,k-2i-2j}
#	+X[0,j,0,l,k-4-2j-l],{j,0,(k-4)/2},{l,0,k-4-2j}
#H^k,1=Sum[j,i-j,0,l,k-4-2i-l],{i,0,(k-4)/2},{j,0,i},{l,0,k-4-2i}
else if d==11 && k>=0 then
	if dimDsub==11 then 
		if n==0 then 
			for i=0 to k/2 do	h0=h0+X[0,i,0,0,k-2*i]; od;
		else if n==1 && k>=4 then
			 for i=0 to (k-4)/2 do h0=h0+X[1,i,0,0,k-4-2*i];od;
		else if n==2 && k>=6 then
			 for i=0 to (k-6)/2 do h0=h0+X[0,i,0,0,k-6-2*i];od;
		else h0=poly_null(rank)
		fi;fi;fi;
	else if dimDsub==10 then
		if n==0 then
			for i=0 to k/2 do
			for j=0 to k-2*i do
			for l=0 to (k-2*i-j)/2 do
				if l!=2 then h0=h0+X[0,i,0,j,k-2*i-j-2*l]; fi;
			od;od;od;
			for i=1 to k/2 do
			for j=0 to (k-2*i)/2 do
			for l=0 to k-2*i-2*j do h0=h0+X[i,j,0,l,k-2*i-2*j-l]
			od;od;od;
			for j=0 to (k-4)/2 do 
			for l=0 to k-4-2*j do h0=h0+X[0,j,0,l,k-4-2*j-l]
			od;od;
		else if n==1 && k>=4 then
			 for i=0 to (k-4)/2 do
			 for j=0 to i do
			 for l=0 to k-4-2*i do h0=h0+X[j,i-j,0,l,k-4-2*i-l]
			od;od;od;
		else h0=poly_null(rank)
		fi;fi;
	fi;fi;
fi;fi;fi;fi;fi;fi;fi;
else if Nsusy==2 then
### D=4 ==> ###
#H^k,0=Sum(X[0,k-2-2i,k-2-2i,k]+X[k-2-2i,0,k-2-2i,-k]),{i,0,(k-2)/2}
#			+Sum[i,k-i,k,k-2i],{i,0,k}
#H^k,1=Sum[i,k-4-i,k-2,k-4-2i],{i,0,k-4}
if d==4 && k>=0 then
	if dimDsub==4 then
		if n==0 then 
			for i=0 to k do h0=h0+X[i,k-i,k,k-2*i];od;
			if k>=2 then
				for i=0 to (k-2)/2 do h0=h0+X[0,k-2-2*i,k-2-2*i,k]+X[k-2-2*i,0,k-2-2*i,-k];od;
			fi;
		else  if n==1 && k>=4 then 
			for i=0 to k-4 do h0=h0+X[i,k-4-i,k-2,k-4-2*i];od;
						else h0=poly_null(rank)
					fi;
		fi;
	fi;#dimDsub==4
fi;#d=4
else if Nsusy==3 then
### D=4 ==> ###
#H^k,0=X[i,k-i,k-i,i,k-2i],{i,0,k}
#			+X[j,k-2i-j,k-2i-j,i+j,k-2j]+X[j,k-2i-j,k-i-j,j,k-4i-2j],{i,1,k/2},{j,0,k-2i}
if d==4 && k>=0 then
	if dimDsub==4 then
		if n==0 then
			for i=0 to k do h0=h0+X[i,k-i,k-i,i,k-2*i];od;
			for i=1 to k/2 do 
				for j=0 to k-2*i do
					h0=h0+X[j,k-2*i-j,k-2*i-j,i+j,k-2*j]+X[j,k-2*i-j,k-i-j,j,k-4*i-2*j]
				od;
			od;
			else h0=poly_null(rank)
		fi;
	fi;#dimDsub==4
fi;#d=4
fi;fi;fi;#Nsusy=3
h0
}
###
degmu(int n,i,j)=
{
loc t=0;
### n=0 ==> ###
if n==0 && i>=0 then
	if i==0 then t=0 else
	if i==1 then t=2 else
	if i==2 then t=3 else
	if i==3 then t=5 else
	if i==4 then t=6 else
	if i==5 then t=8 else
		t=0
	fi;fi;fi;fi;fi;fi;
else if n==1 && i>=0 then
	if i==0 then t=3 else
	if i==1 then 
		if j==1 then t=4 else
		if j==11 then t=5
		fi;fi;
	if i==2 then t=6 else
	if i==3 then t=7 else
	if i==4 then 
		if j==1 then t=8 else
		if j==11 then t=9
		fi;fi;
	if i==5 then 
		if j==1 then t=9 else
		if j==11 then t=10
		fi;fi;
	if i>=6 && i<=16 then t=i+4 else
	  t=0
	fi;fi;fi;fi;fi;fi;fi;
fi;fi;
t}
##### calculate content of superfields #####
# r(m,n) = Sym^m S \otimes Wedge^n(V) #
r(int m,n)=
{
if n<0 then poly_null(rank) else
        if m<0 then poly_null(rank) else
                if n==0 then sym_tensor(m,s) else
                        tensor(sym_tensor(m,s),alt_tensor(n,v))
                fi;
        fi;
fi;
}
##### set negative multiplicities to zero #####
pos_pol(pol p)=
{loc q=p;
for i=1 to length(p) do
        if coef(p,i)<0 then q=q-p[i];
        fi;
od;
q}
#
dim_pol(pol p)=
{
	print(p);print("dim="+dim(p));
	for i=1 to length(p) do
		print("dim("+coef(p,i)+expon(p,i)+")="+dim(p[i]));
	od;
}
##### subtract multiplicities propagating from the left: r(m-2,n+1)->r(m,n) ######
left(int m,n)=
{
loc t=poly_null(rank);
loc n0=0;
if m-2<0 then
        r(m,n);
else
        k=m+2*n;
        if k<2*dimV then n0=k/2 else
                if k>=2*dimV then  n0=dimV
                fi;
        fi;
        t=r(k-2*n0,n0);
        for i=n0-1 downto n do
                t=pos_pol(r(k-2*i,i)-t);
        od;
        t
fi
}
##### subtract multiplicities propagating to the right: r(m,n)->r(m+2,n-1) #####
right(int m,n)=
{
loc t=poly_null(rank);
if n-1<0 then
        r(m,n);
else
        k=m+2*n;
        t=r(k,0);
        for i=1 to n do
                t=pos_pol(r(k-2*i,i)-t);
        od;
        t
# r(m,n)-Ker(m,n);
fi
}
### positive number only ###
pos_num(int m)=
{
	if m>0 then m 
	else 0
	fi;
}
##### subtract multiplicities of one representation propagating from the left ######
left_coef(int n, ilink; vec AA)=
{
	loc t=0;
#	if ilink<n then print("error: ilink<n") else
	# for vector, use size(AA) NOT length(AA) #
	if ilink>=n && ilink<=size(AA) then
		t=AA[ilink];
		for i=ilink-1 downto n do
			t=pos_num(AA[i]-t)
		od;
	fi;
	t
}
##### subtract multiplicities of one representation propagating from the right ######
right_coef(int n, ilink; vec AA)=
{
	loc t=0;
#	if ilink>n then print("error: ilink>n") else
	if n>=ilink && ilink>0 then
		t=AA[ilink];
		for i=ilink+1 to n do
			t=pos_num(AA[i]-t)
		od;
	fi;
	t
}
### Characters ###
#branch(lambda, Tr, id(r))
#char(vec lambda)=branch(lambda, Lie_group(0,rank), id(rank))
#char(vec lambda)=Demazure(lambda)
char(vec lambda) =W_orbit(dom_char(lambda))
char(pol p) =W_orbit(dom_char(p))
##### calculate candidate cohomologies to each differential assuming the maximal propagation #####
# h(int m, n)=pos_pol(r(m,n)-left(m-2,n+1)-right(m+2,n-1))
h(int m, n)=pos_pol(r(m,n)-left(m-2,n+1)-r(m+2,n-1))
hright(int m, n)=pos_pol(r(m,n)-r(m-2,n+1)-right(m+2,n-1))
### check if any ambiguity with maximal propagation ###
ambiguitycheck(int m,n,ii)=
{
  # ambiguity[1]=ambiguitycheck, ambiguity[>=2]=hcoef[n+1] #
	loc ambiguity=null(1);
	loc k=m+2*n;
	loc iMax=k/2;
	if k>2*dimV then iMax=dimV; fi;
	#leftlink, rightlink=index of multiplicity[n+1] #
	loc leftlink=n+2;
	loc rightlink=n;
	loc iAA=0;
	loc AA=expon(r(m,n),ii);
	loc hdiff=0;
	loc hcoef=coef(r(m,n),ii);
	loc mcoef=null(0,1);
	loc multiplicity=null(iMax+1);
	# index n begins from 1 NOT 0 #
	multiplicity[n+1]=hcoef;
	loc isusy=0;
  ### Continuously connected to the left ###
    for i=n+1 to iMax do
         iAA=r(k-2*i,i)|AA;
         if iAA then
         	multiplicity[i+1]=iAA; leftlink=i+1;
        else break
        fi;
    od;
    for i=n-1 downto 0 do
         iAA=r(k-2*i,i)|AA;
         if iAA then
         	multiplicity[i+1]=iAA; rightlink=i+1;
        else break
        fi;
    od;
  ### try to resolve the ambiguity by SUSY condition ###
#  	if leftlink-rightlink>2 && leftlink==iMax && k<=1+2*dimV then
  	if leftlink==iMax+1 && k<=1+2*dimV then
  		multiplicity[iMax]=multiplicity[iMax]-multiplicity[iMax+1];
  		multiplicity[iMax+1]=0;
  		#leftlink=iMax;
#  		isusy=1;
  	fi;
  	if n==iMax && k<=1+2*dimV then mcoef=[[0]]
  	else
  	#if isusy || (leftlink-rightlink>1 && (leftlink<iMax || k>1+2*dimV)) then
  		for i=n downto rightlink do
  			for j=n+2 to leftlink do
# 				if !hdiff then
#  				hdiff=hcoef;
# 					hcoef=pos_num(multiplicity[n]-left_coef(n+1,j,multiplicity)-right_coef(n-1,i,multiplicity));
  					mcoef=mcoef+[pos_num(multiplicity[n+1]-left_coef(n+2,j,multiplicity)-right_coef(n,i,multiplicity))];
#  				hdiff=hcoef-hdiff;
#  			else
#  				break
# 				fi;
  			od;
  		od;
  	fi;
  		mcoef=unique(mcoef);
  		ncoef=n_rows(mcoef);
  	#fi;
  	if ncoef==1 then ambiguity[1]=0;
# 	if !hdiff then ambiguity[1]=0; ambiguity[2]=hcoef;
  	else
  		ambiguity[1]=1
  	fi;
  	for i=1 to ncoef do
  		ambiguity=ambiguity+mcoef[i,1]
  	od;
  ambiguity
}
###
ambiguitycheck(int m,n)=
{
	loc ambiguity=0;
	for i=1 to length(r(m,n)) do
		if ambiguitycheck(m,n,i)[1] then
			ambiguity=1; 
			break;
		fi;
	od;
	ambiguity
}
###
ambiguitycheck_old(int m,n)=
{
  loc ambiguity=0;
  loc k=m+2*n;
  loc m0=k%2;
  loc n0=k/2;
  loc hl=h(m,n);
  loc hr=hright(m,n);
  loc hdiff=hr-hl;
  ### try to resolve the ambiguity by SUSY condition ###
  if coef(hdiff,1)!=0 then
    if k>1+2*dimV then ambiguity=1
    else 
       for i=1 to length(hdiff) do
           if hright(m0,n0)|expon(hdiff,i)!=abs(coef(hdiff,i)) then ambiguity=1; break; fi;
       od;
    fi;   
  fi;
#  if coef(hdiff,1)!=0 then 
#       ambiguity=1;
#       print("Ambiguity exist with maximal propagation!");
#       print("Asumming a propagation to the right:"); print(hl);
#       print("Asumming a propagation to the left:"); print(hr);
#       print("The difference:"); print(hdiff);
#  fi;
  ambiguity
}
###split RR into RR_resolv + RR_amb###
RR_split(int i,j,rightlink)=
{
	loc idiff=0;
	if rightlink==1 then
		 RR_resolv[i+1,j]=RR[i+1,j];
		 #ARR_resolv=ARR_resolv+j;
		else if rightlink==2 then 
			idiff=RR[i+1,j]-RR[i+2,j];
			if idiff!=0 then #ARR_resolv=ARR_resolv+j;
				if idiff>0 then RR_resolv[i+1,j]=idiff
				else RR_resolv[i+2,j]=-idiff
				fi;
			fi;
			else if rightlink==3 then
				idiff=RR[i+2,j]-RR[i+1,j]-RR[i+3,j];
				if idiff>0 then RR_resolv[i+2,j]=idiff; #ARR_resolv=ARR_resolv+j;
					else if idiff<0 then
						RR_amb[i+1,j]=RR[i+1,j];
						RR_amb[i+2,j]=RR[i+2,j];
						RR_amb[i+3,j]=RR[i+3,j];
						ARR_amb=ARR_amb+j;
						fi;
				fi;
				else if rightlink>=4 then
					for t=i+rightlink downto i+1 do
						RR_amb[t,j]=RR[t,j];
					od;
						ARR_amb=ARR_amb+j;
				fi;
			fi;
		fi;
	fi;
}
### propagation analysis ###
RR_prop(int k)=
{
###split RR into RR_resolv + RR_amb###
	loc rightlink=0;
	for j=1 to lenR do
		i=ARR_seg[1,j];
		rightlink=0;
		while i>=ARR_seg[2,j] && ARR_seg[1,j]>0 do
			if RR[i,j] then rightlink=rightlink+1; fi;
			if RR[i,j] && i==ARR_seg[2,j] then
				RR_split(i-1,j,rightlink);
				rightlink=0;
			fi;
			if rightlink && !RR[i,j] then
#DEBUG:
#				print("i:"+i+", j:"+j+", rightlink="+rightlink);
				RR_split(i,j,rightlink);
				rightlink=0;
			fi;
			i=i-1;
		od;
	od;
}
### the coefficients of each representation in Sym^m ^nV represented by a single matrix ###
sum_r(int k)=
{
	loc sumR=poly_null(rank);
	loc ir=poly_null(rank);
	loc iA=[];
#	RR=null(0,1);
	ARR=null(0,rank);
	ARR_amb=null(0);
#	ARR_resolv=null(0);
	lenR=0;
#	lenRR[i+1]:=length(r(k-2*i,i))#
	loc lenRR=null(0);
	loc A_index=0;
#	loc iMax=k/2;
#	if k>2*dimV then iMax=dimV; fi;
  for i=0 to iMax do
  	ir=r(k-2*i,i);
### SUSY condition ###
 	if k<=2*dimV then
 		if i==iMax-1 then ir=pos_pol(ir-r(k-2*iMax,iMax)) else
 			if i==iMax then ir=pos_pol(ir-r(k-2*(iMax-1),iMax-1));fi;
 	fi;fi;
  	sumR=sumR+ir;
  	lenRR=lenRR+length(ir);
  od;
  ARR=support(sumR);
  lenR=length(sumR);
  RR=null(iMax+1,lenR);
  RR_resolv=null(iMax+1,lenR);
  RR_amb=null(iMax+1,lenR);
	RR_map=null(iMax+1,lenR);#The representations of i-th component, to speed the loop
  ARR_seg=null(2,lenR);#The "start" and "end" positions of each representation in the chain complex
	ARR_dim=null(lenR);
  for i=1 to lenR do
#  	iA=expon(sumR,i);
#  	ARR=ARR+iA;
#DEBUG:integer too big
#		print("i="+i);
  	ARR_dim[i]=dim(ARR[i]);
  od;
  for i=iMax downto 0 do
  	ir=r(k-2*i,i);
### SUSY condition ###
 	if k<=2*dimV then
 		if i==iMax then ir=pos_pol(ir-r(k-2*(iMax-1),iMax-1)) else
 			if i==iMax-1 then ir=pos_pol(ir-r(k-2*iMax,iMax));fi;
 	fi;fi;
  	for j=1 to lenRR[i+1] do
  		A_index=row_index(ARR,expon(ir,j),1,lenR);
  		RR[i+1,A_index]=coef(ir,j);
  		RR_map[i+1,A_index]=A_index;
  		if !ARR_seg[1,A_index] then ARR_seg[1,A_index]=i+1;ARR_seg[2,A_index]=i+1;
  			else ARR_seg[2,A_index]=i+1
  		fi;
  	od;
  od;
#  print(ARR);
#  RR
RR_prop(k);
}
### check the dimension of cohomologies with Macaulay2 to resolve the ambiguity ###
dimcheck(int k)=
{
	loc h_dim=null(iMax+1);
	loc dimdiff=null(iMax+1);
	for i=0 to iMax do
#		h_dim[i+1]=h_dim[i+1]+ARR_dim*RR_resolv[i+1];
### check the dimension of cohomologies with Macaulay2 to resolve the ambiguity ###
#		dimdiff[i+1]=dimSeq(dimD, dimD_sub, k, i)-h_dim[i+1];
		dimdiff[i+1]=dimSeq(dimD, dimD_sub, k, i)-ARR_dim*RR_resolv[i+1];
#DEBUG:#
#				print("h_dim["+(i+1)+"]:"+(h_dim[i+1])+"!="+(dimSeq(dimD, dimD_sub, k, i))+"?");
	od;
	dimdiff
}
### h_resolv ###
h_resolv(int k)=
{
	loc h0=poly_null(rank); 
  loc j0=0;
  loc RRmap=null(0);
		for i=0 to iMax do
			h0=poly_null(rank); 
			if RR_resolv[i+1]!=null(lenR) then
				RRmap=vec_mat(unique(mat_vec(RR_map[i+1],1)));
				if RRmap[1] then j0=1 else j0=2;fi;
#DEBUG:
#				print("RRmap:");print(RRmap);
#				print("j0="+j0);
#				for j=1 to lenR do
				for j=j0 to size(RRmap) do
					h0=h0+RR_resolv[i+1,RRmap[j]] X ARR[RRmap[j]];
#					h0=h0+RR_resolv[i+1,j] X ARR[j];
				od;
				print("The cohomologies found when SO("+dimD+") is restricted to its subgroup SO("+dimD_sub+")*SO("+(dimD-dimD_sub)+"), and Nsusy="+Nsusy+":");
	      print("H^"+k+","+i+"=");
	      print(h0);
	     fi;
   od;
	 if ARR_amb!=null(0) then
			print("All of the ambiguous terms can be resolved.");
			print("ARR_amb=");print(ARR_amb);
			#print("RR_amb=");print(RR_amb);
		else 
			print("No ambiguity found.");
	 fi;
}
### the cohomologies ###
hhh(int k)=
{
#	loc k=m+2*n;
	iMax=k/2;
	if k>2*dimV then iMax=dimV; fi;
	loc iamb_max=iMax+1;
	loc iamb_min=1;
	sum_r(k);
	loc dimdiff=null(iMax+1);
###	loc dimdiff_sort=null(0);
###	loc i0=0;
#DEBUG:
#	print("RR_resolv=");print(RR_resolv);
	dimdiff=dimcheck(k);
#	if dimdiff==null(iMax+1) && RR_amb==null(iMax+1,lenR) then
	if dimdiff==null(iMax+1) then
		h_resolv(k);
  else 
  	print("dimdiff=");print(dimdiff);
  	# Try to resolve ambiguity to some simple cases #
###  		dimdiff_sort=sort(dimdiff);
### 			if dimdiff_sort-1!=null(iMax) && k<=2*dimV then
###  		if dimdiff[iMax+1]==0 then
# 				 i=iamb_max;
  			while iamb_max>=2 && dimdiff[iamb_max]==0 do
#DEBUG:
#					print("iamb_max="+iamb_max+", ARR_amb=");print(ARR_amb);print("RR_amb=");print(RR_amb);
  			 	RR[iamb_max-1]=RR[iamb_max-1]-RR_amb[iamb_max];
  			 	RR[iamb_max]=RR[iamb_max]-RR_amb[iamb_max];
  			 	#RR_amb[iamb_max-1]=RR_amb[iamb_max-1]-RR_amb[iamb_max];
  			 	#RR_amb[iamb_max]=null(lenR);
  			 	iamb_max=iamb_max-1;
#DEBUG:  	
#				 	print("RR["+i+"]:");print(RR[i]);
#  			 	i=i-1;
  			 	RR_amb=null(iMax+1,lenR);#recomputed based on RR by RR_prop
					ARR_amb=null(0);#recomputed based on RR by RR_prop
  	 			RR_prop(k);
					dimdiff=dimcheck(k);
  	 		od;
#  	 		i=iamb_min;
  			while iamb_min<iamb_max && dimdiff[iamb_min]==0 do
#DEBUG:
#					print("iamb_min="+iamb_min+", ARR_amb=");print(ARR_amb);print("RR_amb=");print(RR_amb);
  			 	RR[iamb_min+1]=RR[iamb_min+1]-RR_amb[iamb_min];
  			 	RR[iamb_min]=RR[iamb_min]-RR_amb[iamb_min];
  			 	#RR_amb[iamb_min+1]=RR_amb[iamb_min+1]-RR_amb[iamb_min];
  			 	#RR_amb[iamb_min]=null(lenR);
  			 	iamb_min=iamb_min+1;
#  			 	i=i+1;
					RR_amb=null(iMax+1,lenR);#recomputed based on RR by RR_prop
					ARR_amb=null(0);#recomputed based on RR by RR_prop
  	 			RR_prop(k);
					dimdiff=dimcheck(k);
  	 		od;
###  			dimdiff_sort=sort(dimdiff);
###  	 fi;
###  	if dimdiff_sort-1==null(iMax) then
###  		i0=row_index(mat_vec(dimdiff,1),[dimdiff_sort[1]],1,iMax+1);
### 			for i=iMax+1 downto i0+1 do
###  		 RR[i-1]=RR[i-1]-RR_amb[i];
###  		 RR[i]=RR[i]-RR_amb[i];
###  		 RR_amb[i-1]=RR_amb[i-1]-RR_amb[i];
###  		 RR_amb[i]=null(lenR);
###  	 	od;
### 			for i=1 to i0-1 do
###  		 RR[i+1]=RR[i+1]-RR_amb[i];
###  		 RR[i]=RR[i]-RR_amb[i];
###  		 RR_amb[i+1]=RR_amb[i+1]-RR_amb[i];
###  		 RR_amb[i]=null(lenR);
###  	 	od;
###  	 	RR_prop(k);
###			dimdiff=dimcheck(k);  	 	
###  	fi;
		if dimdiff==null(iMax+1) then
				h_resolv(k);
  	else
  			print("Ambiguity found.");print("dimdiff=");print(dimdiff);print("ARR_amb=");print(ARR_amb);print("RR_amb=");print(RR_amb);
  			print("Currently resolved cohomologies are");
  			h_resolv(k);
  			print("Please copy the following code to Mathematica 8 to resolve the multiplicities of the remaining cohomologies in RR_amb: [a_i,j]");
  			loc eqs="";
  			loc cond="";
  			loc tmax=size(ARR_amb);
#  			loc ARRR_amb=null(tmax,rank);
  			loc ARR_amb_alt=null(tmax);
#  			loc Numtype="{"+"Number"+(rank-1)*",Number"+"}";
#  			loc ARR_amb_mmtype="{"+Numtype+(tmax-1)*(","+Numtype)+"}";
  			loc alist="";
#  			loc alist_replace="";
  			for t=1 to tmax do
  				ARR_amb_alt[t]=RR_amb[iamb_max,ARR_amb[t]];
  			od;
  			for i=iamb_max downto iamb_min do
###D=10+1:
  				if dimD==11 && dimD_sub==10 && (i==1 || i==2) then
  					if i==2 then eqs=eqs+"+"+dimdiff[i]
  					else if i==1 then
						#possible cohomologies generated by H^4,1
							loc h0r=poly_null(rank);
							for j=1 to lenR do h0r+=RR_resolv[1,j] X ARR[j];od;
							loc p=r(k-4,0);
							p=p-pos_pol(p-(r(k,0)-h0r));
							loc BD=support(p);
							loc lenBD=length(p);
							for j=1 to lenBD do
								iBD=BD[j];
								iBD_dim=dim(iBD);
								iBD_coef=coef(p,j);
								if iBD_dim<=dimdiff[i] then
							  			eqs=eqs+"+"+iBD_dim+"*a"+(i-1)+BD[j];
							  			cond=cond+" && 0<=a"+(i-1)+BD[j]+"<="+iBD_coef;
							 				if i==iamb_min && j==lenBD then
							 						alist=alist+"a"+(i-1)+BD[j];
							 				else 
													alist=alist+"a"+(i-1)+BD[j]+",";
											fi;
								fi;
							od;
						fi;fi;
					else
###
  				for t=1 to tmax do
  					j=ARR_amb[t];
#  					ARRR_amb[t]=ARR[j];
 					if ARR_dim[j]<=dimdiff[i] then
 						if i==iamb_min && t==tmax then
  							alist=alist+"a["+i+","+j+"]";
#  							alist_replace=alist_replace+"{"+i+","+j+"}->a["+i+","+j+"]";
  						else 
  							alist=alist+"a["+i+","+j+"],";
#  							alist_replace=alist_replace+"{"+i+","+j+"}->a["+i+","+j+"],";
						fi;
  					eqs=eqs+"+"+ARR_dim[j]+"*a["+i+","+t+"]";
  					cond=cond+" && 0<=a["+i+","+t+"]<="+RR_amb[i,j];
  					if i>=iamb_min+1 then	ARR_amb_alt[t]=-ARR_amb_alt[t]+RR_amb[i-1,j];fi;
  					if i>=3 && i>=iamb_min+2 then
  						cond=cond+" && Sum[(-1)^(k-"+(i-1)+")a[k,"+t+"],{k,"+(i-1)+","+iamb_max+"}]<="+ARR_amb_alt[t]
  					else if i==iamb_min+1 then
  						cond=cond+" && Sum[(-1)^(k-"+(i-1)+")a[k,"+t+"],{k,"+(i-1)+","+iamb_max+"}]=="+ARR_amb_alt[t]
  					fi;fi;
  				fi;
  				od;
  				fi;
###
  				if i==iamb_min then
	  				eqs=eqs+"=="+dimdiff[i];
	  			else 
	  				eqs=eqs+"=="+dimdiff[i]+" && ";
	  			fi;
  			od;
#  			print("Reduce["+eqs+cond+"],{"+alist+"},Integers]");
#  			print("matrixlie[str_]:=StringToStream[StringReplace[str,{""[""..->"""",""]""..->"""","" ""..->"""",""\n""->"""","",""->"" ""}]]");
  			print("tmax="+tmax);
  			print("iambmax="+iamb_max);print("iambmin="+iamb_min);
  			print("xsol=Solve["+eqs+cond+",{"+alist+"},Integers]");
#  			print("RRamb=Normal[SparseArray[{"+alist_replace+"}, {"+iMax+","+lenR+"}]]/.xsol");
#  			print("ARRRamb0=""");print(ARRR_amb);print("""");
#  			print("ARRRamb1=matrixlie[ARRRamb0]");
#  			print("ARRRamb=Read[ARRRamb1,"+ARR_amb_mmtype+"]");
#  			print("Close[ARRRamb1]");
#  			print("Hplus[i_]:=Sum[a[i+1,t] ToString[ARRRamb[[t]]],{t,1,tmax}]");
#  			for i=iamb_min to iamb_max do
#  				print("Hplus["+(i-1)+"]/.xsol");
#  			od;
  	fi;
  fi;
}
### the cohomology after resolving the ambiguity from dimension reduction, restrictionMatrix(Nsusy=1) ###
hH(int m,n)=
{
  loc k=m+2*n;
  loc h0=poly_null(rank); 
  loc ambiguity=[];
  loc dimDsub=dimD_sub;
  loc hgen0=X[]; 
  loc hbranch=X[]; 
  loc ihbranch=0; 
  loc ia=[];
		# DEBUG: #
#  	print("checking D="+dimD_sub+"+"+(dimD-dimD_sub)+", m: "+m+", n: "+n);
  if m>=0 && n>=0 then
  if k<=3 then h0=h(m,n); ambiguity=[0];
  else
	for ii=1 to length(r(m,n)) do
		# DEBUG: #
#		print("checking m: "+m+", n: "+n+", ii: "+ii);
		ia=expon(r(m,n),ii);
		ambiguity=ambiguitycheck(m,n,ii);
		# ambiguity[1]=yes/no ambiguity, ambiguity[>=2]=coef #
		if !ambiguity[1] then 
			h0=h0+ambiguity[2] X ia;
		else
	       ### try to resolve the ambiguity from dimension reduction ###
			if dimD_sub%dimD!=0 then
					setparam(dimD);
					if !ambiguitycheck(m,n) then hgen0=h(m,n); # rb0=r(m,n)-h(m,n)-
					else
						ambiguity[1]=2;
						print("Can't resolve the ambiguity for the representation: "+ia+", even before the dimension reduction.");
					fi;
					setparam(dimDsub);
					if coef(hgen0,1)==0 then
						if ambiguity[2]!=0 then print("Can't resolve the ambiguity for the representation: "+ia+", cause h("+m+","+n+")=0."); fi;
					else
							if ambiguity[1]==1 then
								hbranch=branch(hgen0,lieG,restrictionMatrix,sod(dimD));
					    			ihbranch=hbranch|ia;
								if ihbranch<ambiguity[2] then
					    				print("Can't resolve the ambiguity for the representation: "+ia+", cause no corresponding cohomology in D="+dimD)
					    			else
									#for j=2 to n_rows(ambiguity) do
									if ihbranch<ambiguity[3] then 
										h0=h0+ambiguity[2] X ia; ambiguity[1]=0;
									else
												# a conjecture below -- might be wrong! #
										if ambiguity[2]==0 && ihbranch>=ambiguity[3] then
											if size(ambiguity)==3 then ambiguity[1]=0;
											else 
												# a conjecture below -- might be wrong! #
												if size(ambiguity)>=4 then 
													if ihbranch<ambiguity[4] then ambiguity[1]=0; fi;
												fi;
											fi;
											if !ambiguity[1] then
												h0=h0+ambiguity[3] X ia;
											fi;
										else
											print("Can't resolve the ambiguity for the representation: "+ia)
										fi;
									fi;
					    			fi;
					   	fi;
					fi;
				fi;
			fi;
	#DEBUG:		if !ambiguity[1] then print("Found new cohomology:"); print(h0); fi;
		od;
					if ambiguity[1] then
						h0=h(m,n);
					     print("Can't resolve the ambiguity for H^"+k+","+n);
					     print("One conjectured H^"+k+","+n+"=");
					fi;
	        ### the end of the ambiguity resolving ###
	#	       if coef(h0,1)!=0 then
	#	          print("H^"+k+","+n+"=");
	#	          print(h0); 
	#	          hgenNum=hgenNum+1;
		       #print("H^"+k+","+n+"="+(h0)); 
	#	      fi;
	fi;fi;
h0
}
###
hH_old(int m,n)=
{
  loc k=m+2*n;
  loc ambiguity=0;
  loc dimDsub=dimD_sub;
  loc hl=h(m,n); 
  loc hr=hright(m,n); 
  loc hdiff=hr-hl; 
  loc h0=poly_null(rank); 
  loc hgen0=poly_null(rank); 
  loc hbranch=poly_null(rank); 
  loc ihbranch=0; 
  loc ihgenl=0;
  loc ihgenr=0;
  loc ia=[];
      ### Test if the ambiguity could be resolved by SUSY condition ###
       if !ambiguitycheck(m,n) then
          h0=hl;
       else
          ambiguity=1;
       ### try to resolve the ambiguity from dimension reduction ###
          if dimD_sub%dimD!=0 then
              setparam(dimD);
              if !ambiguitycheck(m,n) then hgen0=h(m,n) else ambiguity=2; fi;
              setparam(dimDsub);
            if coef(hgen0,1)!=0 then
               if ambiguity==1 then
                  hbranch=branch(hgen0,lieG,restrictionMatrix,sod(dimD));
                  for j=1 to length(hdiff) do
                      ia=expon(hdiff,j);
                      ihbranch=hbranch|ia;
                      ihgenl=hl|ia;
                      ihgenr=hr|ia;
                      if ihbranch>=ihgenl && (ihbranch<ihgenr || ihgenr==0) then 
                      	   h0=hl;ambiguity=0;
                      else
                         if ihbranch>=ihgenr && (ihbranch<ihgenl || ihgenl==0)then 
                      	      h0=hr; ambiguity=0;
                         else
                            break
                         fi;
                      fi;
                  od;
               fi;
               if ambiguity then
                         if coef(hl,1)!=0 then h0=hl else h0=hr; fi;
                         print("Can't resolve the ambiguity for H^"+k+","+n);
                         print("Conjectured H^"+k+","+n+"=");
                fi;
           fi;
          fi;
        fi; 
        ### the end of the ambiguity resolving ###
#	       if coef(h0,1)!=0 then
#	          print("H^"+k+","+n+"=");
#	          print(h0); 
#	          hgenNum=hgenNum+1;
	       #print("H^"+k+","+n+"="+(h0)); 
#	      fi;
h0
}
##### sum the candidate cohomologies to the degree k #####
coh(int k)=
{
loc t=poly_null(rank);
loc iMax=k/2;
if k>2*dimV then iMax=dimV; fi;
for i=0 to iMax do
        t=t+h(k-2*i, i);
        od;
        t;
}
### cohomologies marked with readable superscript ###
cohlist(int k)=
{
loc t="H_{D="+dimD_sub+"+"+(dimD-dimD_sub)+",k="+k+"}=";
#loc cc="";
loc rH=poly_null(rank);
loc iMax=k/2;
if k>2*dimV then iMax=dimV; fi;
for i=0 to iMax do
#    cc="";
      rH=hH(k-2*i, i);
      for j=1 to length(rH) do
         t=t+" +"+(coef(rH,j))+(expon(rH,j))+"_H("+(k-2*i)+","+(i)+")";
       od;
#       print(cc);
#        t=t+cc;
od;
#print("The cohomologies found when SO("+dimD+") is restricted to its subgroup SO("+dimD_sub+")*SO("+(dimD-dimD_sub)+"), and Nsusy="+Nsusy+":");
print(t);
#print("where _H(m,n) corresponds to the cohomology found in Sym^{m}S wedge^{n}V");
}
### The cohomology generators ###
hgen(int m, n)=pos_pol(hH(m,n)-tensor(s,hH(m-1,n)))
hgen_formula(int k, n)=pos_pol(h_formula(dimD,dimD_sub,k,n)-tensor(s,h_formula(dimD,dimD_sub,k-1,n)))
hgenright(int m, n)=pos_pol(hright(m,n)-tensor(s,hright(m-1,n)))
hgendimD(int m,n)=
{
   loc dimDsub=dimD_sub;
   loc h0=poly_null(rank);
   setparam(dimD);
   if !ambiguitycheck(m,n) then h0=hgen(m,n) else h0=poly_null(rank); fi;
   setparam(dimDsub);
   h0
}
hgenlist(int maxk)=
{
	loc hgenNum=0;
	loc iMax=0;
  print("The cohomology generators beside of the spinor and 1 assuming maximal propagation when D="+dimD_sub+"+"+(dimD-dimD_sub)+", N="+Nsusy+":");
### The generator h(1,0) is the spinor ###
# print("H^"+1+","+0+"="); print(h(1,0)); 
for ikk=2 to maxk do
   #print("k="+ikk+":");
   iMax=ikk/2;
   if ikk>2*dimV then iMax=dimV; fi;
   for i=0 to iMax do
#SWITCH hgen calculation method:
#1:	      if coef(hgen(ikk-2*i,i),1)!=0 then
	      if coef(hgen_formula(ikk,i),1)!=0 then
	         print("H^"+ikk+","+i+"=");
#1:	         print(hgen(ikk-2*i,i)); 
	         print(hgen_formula(ikk,i)); 
	         #print("H^"+ikk+","+i+"="+(hgen(ikk-2*i,i))); 
	         hgenNum=hgenNum+1;
	      fi;
   od;
od;
if hgenNum==0 then 
    print("No other cohomology generators!");
else
    print(hgenNum+" cohomology generators found, where H^{k,n} corresponding to Sym^{k-2n} S \otimes Wedge^n V");
 fi;
print(18*"-");
}
hgenlist()=hgenlist(dimD+4)
# hgenlist()=hgenlist(2*dimV+2)
###
hgenlist_old(int maxk)=
{
  loc hgenNum=0;
  loc m=0;
  loc ambiguity=0;
  loc dimDsub=dimD_sub;
  loc hdiff=poly_null(rank); 
  loc hr=poly_null(rank); 
  loc hl=poly_null(rank); 
  loc h0=poly_null(rank); 
  loc hgen0=poly_null(rank); 
  loc hbranch=poly_null(rank); 
  loc ihbranch=0; 
  loc ihgenl=0;
  loc ihgenr=0;
  print("The cohomology generators beside of the spinor and 1 assuming maximal propagation when D="+dimD_sub+"+"+(dimD-dimD_sub)+", N="+Nsusy+":");
### The generator h(1,0) is the spinor ###
# print("H^"+1+","+0+"="); print(h(1,0)); 
for ikk=2 to maxk do
    iMax=ikk/2;
    if ikk>2*dimV then iMax=dimV; fi;
    for i=0 to iMax do
       m=ikk-2*i;
       hl=hgen(m,i); 
       hr=hgenright(m,i);
       hdiff=hr-hl;
       ### Test if the ambiguity could be resolved by SUSY condition ###
       if !ambiguitycheck(m,i) then
          h0=hl;
       else
          ambiguity=1;
       ### try to resolve the ambiguity from dimension reduction ###
          if dimD_sub%dimD!=0 then
              setparam(dimD);
              if !ambiguitycheck(m,i) then hgen0=hgen(m,i) else ambiguity=2; fi;
              setparam(dimDsub);
            if coef(hgen0,1)==0 then break
            else
               if ambiguity==1 then
                  hbranch=branch(hgen0,lieG,restrictionMatrix,sod(dimD));
                  for j=1 to length(hl) do
                      ihbranch=hbranch|expon(hl,j);
                      ihgenr=hr|expon(hl,j);
                      if ihbranch>=coef(hl,j) && (ihgenr==0 || ihgenr>ihbranch) then ambiguity=0
                      else
                          ambiguity=1; break;
                      fi;
                  od;
                  if !ambiguity then h0=hl
                  else 
                       for j=1 to length(hr) do
                           ihbranch=hbranch|expon(hr,j);
                           ihgenl=hl|expon(hr,j);
                           if ihbranch>=coef(hr,j) && (ihgenl==0 || ihgenl>ihbranch) then ambiguity=0
                           else 
                              ambiguity=1; break;
                           fi;
                      od;
                      if !ambiguity then h0=hr; fi;
                  fi;
               fi;
               if ambiguity then
                         if coef(hl,1)!=0 then h0=hl else h0=hr; fi;
                         print("Can't resolve the ambiguity for H^"+ikk+","+i);
                         print("Conjectured H^"+ikk+","+i+"=");
                         print(h0); 
                fi;
           fi;
          fi;
        fi; 
        ### the end of the ambiguity resolving ###
	       if coef(h0,1)!=0 then
	          print("H^"+ikk+","+i+"=");
	          print(h0); 
	          hgenNum=hgenNum+1;
	       #print("H^"+ikk+","+i+"="+(h0)); 
	      fi;
    od;
od;
if hgenNum==0 then 
    print("No other cohomology generators!");
else
    print(hgenNum+" cohomology generators found, where H^{k,n} corresponding to Sym^{k-2n} S \otimes Wedge^n V");
 fi;
print(18*"-");
}
### Test if the representations for the spinor and the vector is all right? ###
susytest()=
{
print(25*"-");print(dimD+"D="+dimD_sub+"+"+(dimD-dimD_sub)+", Nsusy="+Nsusy+":");
#print("s=");print(s);print("v=");print(v);
#if coef(r(0,1)-h(0,1),1)!=0 && dim(v)==dimD && (r(2,1)/(all_one(rank-1)+(Ncomplexify*10^9+1)))|null(rank)>0 then print("Good choice of representations of the spinor s and the vector v!") else 
if coef(r(0,1)-h(0,1),1)>0 && dim(v)==dimD_sub && r(2,1)|null(rank)>0 then print("Good choice of representations of the spinor s and the vector v!") else 
   print("Bad choice of representations of the spinor s or the vector v!?");
   print("coef(r(0,1)-h(0,1),1)>0?  "+(coef(r(0,1)-h(0,1),1)));
   print("dim(v)==dimD_sub?  "+(dim(v)));
   print("r(2,1)|null(rank)>0?  "+(r(2,1)|null(rank)));
   fi;
}
susytest
### Euler characteristics of cohomology ###
eulercoh(int k)=
{
loc t=poly_null(rank);
loc iMax=k/2;
if k>2*dimV then iMax=dimV; fi;
for i=0 to iMax do
        t=t+ (-1)^i*h(k-2*i, i);
        od;
        t
}
### alt_sum ###
altsum(int k)=
{
	loc t=poly_null(rank);
	loc iMax=k/2;
	if k>2*dimV then iMax=dimV; fi;
	for i=0 to iMax do
        t=t+ (-1)^i*r(k-2*i, i);
        od;
        t
}
### Euler characteristics of a representation in the cochain complex  ###
eulerChar(vec Arep; int k)=
{
loc t=0;
loc iMax=k/2;
if k>2*dimV then iMax=dimV; fi;
for i=0 to iMax do
        t=t+ (-1)^i*(r(k-2*i, i)|Arep);
        od;
        t
}
### check whether the two Euler characteristics above are equal ###
eulercheck(int kmax)=
{
loc t1=poly_null(rank);
loc t2=poly_null(rank);
loc Arep=[];
loc lt=0;
print("Check the Euler characteristics when D="+dimD_sub+"+"+(dimD-dimD_sub)+", Nsusy="+Nsusy);
for ik=2 to kmax do
     t1=eulercoh(ik);
     t2=poly_null(rank);
     lt=length(t1);
    for i=1 to lt do
        Arep=expon(t1,i);
        t2=t2+eulerChar(Arep,ik) X Arep;
      od;
      print(18*"-");
      print("Euler characteristics of the cohomology:");
      print("chi{H("+ik+")}:"); print(t1);
      print("Euler characteristics from the alt_sum of the multiplicities in the cochain complex"); print(t2);
      if t1==t2 then print("Bingle! The Euler characteristics are verified when k="+ik) else
         print("Problem in the Euler characteristics of the cohomology when k="+ik)
      fi;
   od;
}
# eulercheck()=eulercheck(2*dimV+4)
eulercheck()=eulercheck(dimD+4)
##### Prove the maximal propagation #####
### different variable name kk ###
# sed -e :a -e '$!N;s/\n[[:space:]]*\\//g;s/\\\n[[:space:]]*//g;s/==>+/==>/g;ta' -e 'P;D' result.txt >result_formated.txt#
# sed -e '{s/\ //g; s/\\//g;}' result.txt |awk '{printf"%s",$0}' |sed -e 's/==>+/\n==>/g;s/:/:\n/g;'#
maxprop(int kk)=
{
iMax=kk/2;
if kk>2*dimV then iMax=dimV; fi;
# if kk>4*(rank-Ncomplexify) then iMax=2*(rank-Ncomplexify); fi;
print("k="+kk+":");
loc mincoef=0;
loc rB=poly_null(rank);
loc rH=poly_null(rank);
loc HH=poly_null(rank);
loc HH_text="";
loc cc="";
loc list_SxTensor=0;
if list_SxTensor==1 then
  for i=iMax downto 0 do
      SxH=tensor(s,h(kk-1-2*i, i));
      for j=1 to length(h(kk-1-2*i, i)) do
         cc=(coef(h(kk-1-2*i,i),j))+"Sx"+(expon(h(kk-1-2*i,i),j))+"_H"+(i)+"=";
         #print("Sx\");
         #print(h(kk-1-2*i,i)[j]);
         #print("\_H_"+(i)+"=\");
         print(cc);
         print(SxH);
      od;
#      B_lowk=pos_pol(r(kk-1-2*i,i)-h(kk-1-2*i,i)-r(kk-1-2*(i-1),i-1));
      B_lowk=left(kk-1-2*i,i)-h(kk-1-2*i,i);
      SxB=tensor(s,B_lowk);
      for j=1 to length(B_lowk) do
         SB=tensor(s,B_lowk[j]);
         cc=(coef(B_lowk,j))+"Sx"+(expon(B_lowk,j))+"_PB"+(i)+"=";
        ### PB here denote the preimage of boundaries ###
         print(cc);
         print(SB);
      od;
 od;
fi;
###
print("");print("The chain complex when k="+kk+", D="+dimD_sub+"+"+(dimD-dimD_sub)+", Nsusy="+Nsusy+":");
print("0==>") ;
for i=iMax downto 0 do
      cc="==>";
#      SxH=tensor(s,h(kk-1-2*i, i));
#      B_lowk=pos_pol(r(kk-1-2*i,i)-h(kk-1-2*i,i)-r(kk-1-2*(i-1),i-1));
### Assume maximal propagation for low k ###
#      B_lowk=right(kk-1-2*(i-1),i-1)-h(kk-1-2*(i-1),i-1);
      B_lowk=left(kk-1-2*i,i)-h(kk-1-2*i,i);
      SxB=tensor(s,B_lowk);
       # print("==>");
      for j=1 to length(rB) do
        cc=cc+" +"+(coef(rB,j))+(expon(rB,j))+"_B"+(i+1);
      od;
### supersymmetry condition ###
#   if kk<=2*dimV && i*2==kk then
#       rB=r(0,kk/2); 
#       rH=poly_null(rank);
#   else
      rHrB=r(kk-2*i,i)-rB;
      rB=poly_null(rank);
      for j=1 to length(rHrB) do
         if coef(rHrB,j)<=r(kk-2*(i-1),i-1)|expon(rHrB,j) then mincoef=coef(rHrB,j) else mincoef=r(kk-2*(i-1),i-1)|expon(rHrB,j); fi;
         if (kk>2*dimV || i*2!=kk) && mincoef>SxB|expon(rHrB,j) then mincoef=SxB|expon(rHrB,j); fi;
#         if !kk<=2*dimV && !i*2==kk && mincoef>SxB|expon(rHrB,j) then mincoef=SxB|expon(rHrB,j); fi;
#           if mincoef>SxB|expon(rHrB,j) then mincoef=SxB|expon(rHrB,j); fi;
         rB=rB+mincoef X expon(rHrB,j);
      od;
      rH=rHrB-rB;
#   fi;
      HH=HH+rH;
      for j=1 to length(rB) do
         cc=cc+" +"+(coef(rB,j))+(expon(rB,j))+"_PB"+(i);
         # print("\+\");
         # print(rB[j]);
         ### B here denote the boundaries###
         # print("\_B_"+(i));
       od;
      for j=1 to length(rH) do
         cc=cc+" +"+(coef(rH,j))+(expon(rH,j))+"_H"+(i);
         HH_text=HH_text+" +"+(coef(rH,j))+(expon(rH,j))+"_H("+(kk-2*i)+","+(i)+")";
         # print("\+\");
         # print(rH[j]);
         ### H here denote the cohomologies###
         # print("\_H_"+(i));
       od;
       print(cc);
  od;
print("==>0");
print("where _H, _B, _PB denote the cohomology, boundary, and preimage of boundary, respectively.");
print("Cohomology:");
print(HH_text);
if HH==coh(kk) then 
   print("Bingle! Our cohomology formula is verified.");
else
   print("The maximal propagation principle might be not sufficient here!")
fi;
}
### Sx[a,b,c,d,e], [a,b,c,d,e]x\wedge^nV ###
# NO if else if fi, BUT if else fi, OR if else if fi;fi; #
xsv(int n; vec iv)={
	loc aRep=6*rank*all_one(rank);
	loc isv=poly_null(rank);
	if n==0 then isv=tensor(s, 1 X aRep) else
		if n>=1 then isv=tensor(1 X aRep, r(0,n)) fi;
		fi;
	loc lensv=length(isv);
	loc epsi=null(lensv, rank);
	loc sv=poly_null(rank);
	loc av=null(rank);
	loc avt="[";
	for i=1 to rank do
	  avt=avt+"a"+i+",";
	 od;
 	if n==0 then print("Sx"+avt+"]=") else
	if n>=1 then print(avt+"] x \wedge^"+(n)+"V="); fi;
#	if n==0 then print("Sx[a,b,c,d,e]=") else
#		if n>=1 then print("[a,b,c,d,e] x \wedge^"+(n)+"V="); fi;
	fi;
	for i=1 to lensv do
	    im=1;
	    avtx="X[";
	    for j=1 to rank do
	        epsi[i,j]=expon(isv,i)[j]-aRep[j];
	        if epsi[i,j]>=0 then
	           avtx=avtx+" a"+j+"+"+(epsi[i,j])+","
	          else avtx=avtx+" a"+j+(epsi[i,j])+","; 
	         fi;
	        av[j]=iv[j]+epsi[i,j];
	        if av[j]<0 then im=0; fi;
	     od;
	     print("+"+(coef(isv,i))+avtx+"]");
	    # print("+"+(coef(isv,i))+"X[a+"+(epsi[i,1])+",b+"+(epsi[i,2])+",c+"+(epsi[i,3])+",d+"+(epsi[i,4])+",e+"+(epsi[i,5])+"]");
	    if im==1 then
	      	sv=sv+coef(isv,i) X av;
	   fi;
	 od;
	 print("epsilon=");
	 print(epsi);
	 print(sv);
	 if n==0 then print("The result above differed with Sx"+(iv)+":");
	 else
	    print("The result above differed with "+(iv)+"x\wedge^"+n+"V:");
	 fi;
	 if n==0 then print(sv-tensor(s,1 X iv)) else
	 	if n>=1 then print(sv-tensor(1 X iv, r(0,n))) fi;
	 	fi;
}
### alt_mu=M x altS M=sum_k H^k,n ###
alt_mu(int d, dimDsub, kMax, n)=
{
	setparam(dimDsub);
	loc jmax=0;
	loc dimS=dim(s);
	loc altmu=poly_null(rank);
	for i=0 to kMax do
		if i<dimS then jmax=i
		else jmax=dimS
		fi;
		altmu=poly_null(rank);
		for j=0 to jmax do
			altmu+=(-1)^j*tensor(h_formula(d, dimDsub, i-j, n),alt_tensor(j,s));
		od;
		if coef(altmu,1)!=0 then
			print(dim(altmu)+"T^"+i+": ");
			print(altmu);
		fi;
	od;
#	for i=1 to length(altmu) do
#		if altmu2|expon(altmu,i)==coef(altmu,i) then altmu_stable+=altmu[i]
#		fi;
#	od;
#	altmu_stable
}
alt_mu(int kMax, n)=alt_mu(dimD, dimD_sub, kMax, n)
### alt_mu=M x altS M=sum_k H^k,n ###
alt_mu1(int d, dimDsub, kMax, n)=
{
	setparam(dimDsub);
	loc sumH=poly_null(rank);
	loc sumH2=poly_null(rank);
	loc altS=poly_null(rank);
	loc altmu=poly_null(rank);
	loc altmu2=poly_null(rank);
	loc altmu_stable=poly_null(rank);
	for i=0 to kMax do
		sumH=sumH+h_formula(d, dimDsub, i, n);
	od;
		sumH2=sumH+h_formula(d, dimDsub, kMax+1, n);
	for i=0 to dim(s) do
		altS=altS+(-1)^i*alt_tensor(i,s);
	od;
	altmu=tensor(sumH,altS);
	altmu2=tensor(sumH2,altS);
	for i=1 to length(altmu) do
		if altmu2|expon(altmu,i)==coef(altmu,i) then altmu_stable+=altmu[i]
		fi;
	od;
	altmu_stable
}
alt_mu1(int kMax, n)=alt_mu1(dimD, dimD_sub, kMax, n)
### search scalars in representations for one certain reduction ###
scalarsearch(int dimDsub,k0,kmax)=
{
setparam(dimDsub);
#loc kmax=2*dim(v)+4;
#loc kmax=18;
loc imax=0;
loc numscalar=0;
loc numscalar_alt=0;
# loc sResult="";
# loc vResult="";
print("Scalars found when SO("+dimD+") is restricted to its subgroup SO("+dimDsub+")*SO("+(dimD-dimDsub)+"), and Nsusy="+Nsusy+":");
print("s="); print(s); print("v=");print(v);
 for ik=k0 to kmax do
 			numscalar_alt=0;
      if ik>2*dim(v) then imax=dim(v) else 
         imax=ik/2;  fi;
    for i=0 to imax do
       m=ik-2*i;
#       numscalar=contragr(r(m,0))|expon(r(0,i),1);
       numscalar=r(m,i)|null(rank);
       numscalar_alt=-numscalar_alt+numscalar;
       if numscalar>0 then 
#         if m==0 then sResult="" else
#            if m==1 then sResult="S" else
#               sResult="Sym^"+m+" S";    fi;fi;
#         if i==0 then vResult="" else
#            vResult="wedge^"+i+" V";    fi;
      print("-->k="+ik+": Sym^"+m+"S"+" wedge^"+i+"V contains "+numscalar+" scalars.");
      fi;
    od;
    if numscalar_alt!=0 then
      print("k="+ik+": Euler characteristic contains "+abs(numscalar_alt)+" scalars.");
		fi;
 od;
}
#
scalarsearch(int dimDsub)=scalarsearch(dimDsub,2,2*dim(v)+4)
###euler char check for H_s^0###
altHs(int d, dimDsub, l, n)=
{
	setparam(dimDsub);
	loc jmax=0;
	loc dimS=dim(s);
	loc alths=poly_null(rank);
	if l<dimS then jmax=l
	else jmax=dimS
	fi;
	for i=0 to jmax do
		alths+=(-1)^i*tensor(h_formula(d, dimDsub, l-i+2*n, n),alt_tensor(i,s));
	od;
alths
}
### do batch jobs for all possible dimension reductions ###
reductD()=
{
loc kmax=0;
loc h0=X[];
for iDim=2 to 2 do
# for iDim=1 to dimD do
   setparam(iDim);
   kmax=2*dim(v)+4;
   print(25*"*");
#   print("The cohomologies found when SO("+dimD+") is restricted to its subgroup SO("+iDim+")*SO("+(dimD-iDim)+"), and Nsusy="+Nsusy+":");
#   print("Here _H(m,n) corresponds to the cohomology found in Sym^{m}S wedge^{n}V");
   print("s=");
   print(s);
   print("v=");
   print(v);
   scalarsearch(iDim);
###   hgenlist(iDim+4);
###    eulercheck(kmax);
#####   	print(24*"@");
#####	print("The 0-cohomologies found for D="+iDim+"+"+(dimD-iDim));
#####	kmax=12;
#####   for ik=2 to kmax do
#####   		h0=hH(ik,0);
#####		print("H("+ik+",0)="); print(h0);
#####		print("The dimension of H("+ik+",0)="+(dim(h0)));
#     print(cohlist(ik));
#####   od;
od;
}
#
susyTestall()=
{
for Nsusy=1 to 4 do
	for i=0 to 8 do
		for dimD_sub=3 to 11 do
			dimD=dimD_sub+i;
			setparam(dimD_sub);
			susytest;
		od;
	od;
od;
}
